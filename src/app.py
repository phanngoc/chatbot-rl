"""
Streamlit Web Interface cho RL Chatbot
"""

import streamlit as st
import json
import os
import pandas as pd
import plotly.express as px
import plotly.graph_objects as go
from datetime import datetime, timedelta
import time

from agents.rl_chatbot import RLChatbotAgent


@st.cache_resource
def load_agent():
    """Load RL Chatbot Agent v·ªõi caching"""
    config = {
        "model_name": "microsoft/DialoGPT-medium",
        "device": "cpu",
        "experience_buffer_size": 5000,
        "memory_store_type": "chroma",
        "max_memories": 2000,
        "consolidation_threshold": 50,
        "ewc_lambda": 500.0,
        "temperature": 0.8
    }
    
    agent = RLChatbotAgent(config=config)
    
    # Try to load existing state
    state_path = "data/agent_state.json"
    if os.path.exists(state_path):
        agent.load_agent_state(state_path)
    
    return agent


def initialize_session_state():
    """Initialize Streamlit session state"""
    if 'conversation_history' not in st.session_state:
        st.session_state.conversation_history = []
    
    if 'conversation_id' not in st.session_state:
        st.session_state.conversation_id = None
    
    if 'agent' not in st.session_state:
        st.session_state.agent = load_agent()


def chat_interface():
    """Main chat interface"""
    st.header("ü§ñ RL Chatbot - Tr√≤ chuy·ªán")
    
    agent = st.session_state.agent
    
    # Start conversation if needed
    if not st.session_state.conversation_id:
        st.session_state.conversation_id = agent.start_conversation()
        st.success(f"B·∫Øt ƒë·∫ßu cu·ªôc tr√≤ chuy·ªán m·ªõi: {st.session_state.conversation_id}")
    
    # Chat input
    user_input = st.chat_input("Nh·∫≠p tin nh·∫Øn c·ªßa b·∫°n...")
    
    if user_input:
        # Add user message to history
        st.session_state.conversation_history.append({
            "role": "user",
            "content": user_input,
            "timestamp": datetime.now()
        })
        
        # Process message
        with st.spinner("ƒêang suy nghƒ©..."):
            result = agent.process_message(user_input)
        
        # Add bot response to history
        st.session_state.conversation_history.append({
            "role": "assistant",
            "content": result['response'],
            "timestamp": datetime.now(),
            "metadata": {
                "experience_id": result['experience_id'],
                "memories_used": result['relevant_memories_count'],
                "response_time_ms": result['response_time_ms']
            }
        })
    
    # Display conversation
    for i, message in enumerate(st.session_state.conversation_history):
        if message["role"] == "user":
            with st.chat_message("user"):
                st.write(message["content"])
        else:
            with st.chat_message("assistant"):
                st.write(message["content"])
                
                # Show metadata for bot messages
                if "metadata" in message:
                    with st.expander("üìä Chi ti·∫øt"):
                        metadata = message["metadata"]
                        col1, col2, col3 = st.columns(3)
                        with col1:
                            st.metric("Memories Used", metadata["memories_used"])
                        with col2:
                            st.metric("Response Time", f"{metadata['response_time_ms']:.1f}ms")
                        with col3:
                            # Feedback buttons
                            feedback_key = f"feedback_{metadata['experience_id']}"
                            
                            col_pos, col_neg = st.columns(2)
                            with col_pos:
                                if st.button("üëç", key=f"{feedback_key}_pos"):
                                    agent.provide_feedback(metadata['experience_id'], 0.8)
                                    st.success("C·∫£m ∆°n feedback t√≠ch c·ª±c!")
                            with col_neg:
                                if st.button("üëé", key=f"{feedback_key}_neg"):
                                    agent.provide_feedback(metadata['experience_id'], -0.8)
                                    st.success("C·∫£m ∆°n feedback, t√¥i s·∫Ω c·∫£i thi·ªán!")
    
    # Sidebar controls
    with st.sidebar:
        st.subheader("üéõÔ∏è ƒêi·ªÅu khi·ªÉn")
        
        if st.button("üîÑ Cu·ªôc tr√≤ chuy·ªán m·ªõi"):
            st.session_state.conversation_history = []
            st.session_state.conversation_id = agent.start_conversation()
            st.rerun()
        
        if st.button("üíæ L∆∞u tr·∫°ng th√°i"):
            success = agent.save_agent_state("data/agent_state.json")
            if success:
                st.success("ƒê√£ l∆∞u tr·∫°ng th√°i!")
            else:
                st.error("L·ªói khi l∆∞u tr·∫°ng th√°i!")
        
        # Conversation stats
        if st.session_state.conversation_history:
            st.subheader("üìä Th·ªëng k√™ cu·ªôc tr√≤ chuy·ªán")
            
            user_messages = [m for m in st.session_state.conversation_history if m["role"] == "user"]
            bot_messages = [m for m in st.session_state.conversation_history if m["role"] == "assistant"]
            
            st.metric("T·ªïng tin nh·∫Øn", len(st.session_state.conversation_history))
            st.metric("Tin nh·∫Øn c·ªßa b·∫°n", len(user_messages))
            st.metric("Ph·∫£n h·ªìi c·ªßa bot", len(bot_messages))
            
            if bot_messages:
                avg_response_time = sum(
                    m.get("metadata", {}).get("response_time_ms", 0) 
                    for m in bot_messages
                ) / len(bot_messages)
                st.metric("Th·ªùi gian ph·∫£n h·ªìi TB", f"{avg_response_time:.1f}ms")


def analytics_dashboard():
    """Analytics dashboard"""
    st.header("üìä B·∫£ng ƒëi·ªÅu khi·ªÉn ph√¢n t√≠ch")
    
    agent = st.session_state.agent
    
    # Get system status
    status = agent.get_system_status()
    
    # Overview metrics
    col1, col2, col3, col4 = st.columns(4)
    
    with col1:
        st.metric(
            "T·ªïng t∆∞∆°ng t√°c", 
            status['performance_metrics']['total_interactions']
        )
    
    with col2:
        st.metric(
            "Feedback t√≠ch c·ª±c", 
            status['performance_metrics']['positive_feedback']
        )
    
    with col3:
        st.metric(
            "Feedback ti√™u c·ª±c", 
            status['performance_metrics']['negative_feedback']
        )
    
    with col4:
        st.metric(
            "Th·ªùi gian ph·∫£n h·ªìi TB", 
            f"{status['performance_metrics']['avg_response_time']:.2f}s"
        )
    
    # Memory systems status
    st.subheader("üß† Tr·∫°ng th√°i h·ªá th·ªëng b·ªô nh·ªõ")
    
    memory_stats = status['memory_systems']
    
    # Experience buffer
    col1, col2 = st.columns(2)
    
    with col1:
        st.subheader("üìö Experience Buffer")
        buffer_stats = memory_stats['experience_buffer']
        
        # Buffer utilization
        utilization = buffer_stats['buffer_utilization']
        fig = go.Figure(go.Indicator(
            mode = "gauge+number",
            value = utilization,
            domain = {'x': [0, 1], 'y': [0, 1]},
            title = {'text': "Buffer Utilization (%)"},
            gauge = {
                'axis': {'range': [None, 100]},
                'bar': {'color': "darkblue"},
                'steps': [
                    {'range': [0, 50], 'color': "lightgray"},
                    {'range': [50, 80], 'color': "yellow"},
                    {'range': [80, 100], 'color': "red"}
                ],
                'threshold': {
                    'line': {'color': "red", 'width': 4},
                    'thickness': 0.75,
                    'value': 90
                }
            }
        ))
        fig.update_layout(height=300)
        st.plotly_chart(fig, use_container_width=True)
        
        # Experience distribution
        if buffer_stats['total_experiences'] > 0:
            experience_data = {
                'Type': ['Positive', 'Negative', 'Neutral'],
                'Count': [
                    buffer_stats['positive_experiences'],
                    buffer_stats['negative_experiences'], 
                    buffer_stats['neutral_experiences']
                ]
            }
            
            fig = px.pie(
                values=experience_data['Count'],
                names=experience_data['Type'],
                title="Ph√¢n ph·ªëi Experience"
            )
            st.plotly_chart(fig, use_container_width=True)
    
    with col2:
        st.subheader("üîç Retrieval Memory")
        retrieval_stats = memory_stats['retrieval_memory']
        
        if retrieval_stats['total_memories'] > 0:
            st.metric("T·ªïng memories", retrieval_stats['total_memories'])
            st.metric("Avg importance", f"{retrieval_stats['avg_importance']:.2f}")
            st.metric("Max access count", retrieval_stats['max_access_count'])
            
            # Memory importance distribution
            importance_data = {
                'Category': ['Highly Important', 'Low Important', 'Others'],
                'Count': [
                    retrieval_stats['highly_important_memories'],
                    retrieval_stats['low_importance_memories'],
                    retrieval_stats['total_memories'] - 
                    retrieval_stats['highly_important_memories'] - 
                    retrieval_stats['low_importance_memories']
                ]
            }
            
            fig = px.bar(
                x=importance_data['Category'],
                y=importance_data['Count'],
                title="Ph√¢n ph·ªëi Importance"
            )
            st.plotly_chart(fig, use_container_width=True)
        else:
            st.info("Ch∆∞a c√≥ memories n√†o")
    
    # Temporal weighting stats
    st.subheader("‚è∞ Temporal Weighting")
    temporal_stats = memory_stats['temporal_weighting']
    
    if temporal_stats['total_experiences'] > 0:
        col1, col2, col3 = st.columns(3)
        
        with col1:
            st.metric("Total Experiences", temporal_stats['total_experiences'])
        
        with col2:
            weight_dist = temporal_stats['weight_distribution']
            st.metric("Mean Weight", f"{weight_dist['mean']:.3f}")
        
        with col3:
            st.metric("High Weight Experiences", temporal_stats['high_weight_experiences'])
        
        # Weight components
        components = temporal_stats['component_weights']
        component_data = {
            'Component': ['Temporal', 'Importance', 'Access', 'Quality'],
            'Mean': [
                components['temporal']['mean'],
                components['importance']['mean'],
                components['access']['mean'],
                components['quality']['mean']
            ]
        }
        
        fig = px.bar(
            x=component_data['Component'],
            y=component_data['Mean'],
            title="Trung b√¨nh Weight Components"
        )
        st.plotly_chart(fig, use_container_width=True)
    
    # Meta-learning stats
    st.subheader("üéØ Meta-Learning")
    meta_stats = memory_stats['meta_learning']
    
    col1, col2, col3 = st.columns(3)
    
    with col1:
        st.metric("Episodes Trained", meta_stats['meta_learning']['episodes_trained'])
    
    with col2:
        st.metric("Experience Buffer Size", meta_stats['experience_buffer_size'])
    
    with col3:
        memory_bank = meta_stats['memory_bank']
        st.metric("Memory Utilization", f"{memory_bank['total_memories']}/1000")


def memory_explorer():
    """Memory exploration interface"""
    st.header("üîç Kh√°m ph√° b·ªô nh·ªõ")
    
    agent = st.session_state.agent
    
    # Search interface
    st.subheader("üîé T√¨m ki·∫øm memories")
    
    search_query = st.text_input("Nh·∫≠p t·ª´ kh√≥a t√¨m ki·∫øm:")
    
    if search_query:
        # Search in retrieval memory
        memories = agent.retrieval_memory.retrieve_relevant_memories(
            search_query, top_k=10
        )
        
        if memories:
            st.success(f"T√¨m th·∫•y {len(memories)} memories li√™n quan")
            
            for i, memory in enumerate(memories):
                with st.expander(f"Memory {i+1} - Similarity: {memory['similarity']:.3f}"):
                    st.write("**Content:**", memory['content'])
                    st.write("**Context:**", memory['context'])
                    st.write("**Importance:**", memory['importance_score'])
                    st.write("**Access Count:**", memory['access_count'])
                    st.write("**Tags:**", ", ".join(memory['tags']))
                    
                    if memory['metadata']:
                        st.write("**Metadata:**", memory['metadata'])
        else:
            st.info("Kh√¥ng t√¨m th·∫•y memories n√†o")
    
    # Recent experiences
    st.subheader("üìù Experiences g·∫ßn ƒë√¢y")
    
    if len(agent.experience_buffer.buffer) > 0:
        recent_experiences = list(agent.experience_buffer.buffer)[-10:]  # Last 10
        
        for i, exp in enumerate(reversed(recent_experiences)):
            with st.expander(f"Experience {i+1} - Reward: {exp.reward:.2f}"):
                st.write("**State:**", exp.state)
                st.write("**Action:**", exp.action)
                st.write("**Reward:**", exp.reward)
                st.write("**Timestamp:**", exp.timestamp.strftime("%Y-%m-%d %H:%M:%S"))
                if exp.user_feedback:
                    st.write("**User Feedback:**", exp.user_feedback)
    else:
        st.info("Ch∆∞a c√≥ experiences n√†o")
    
    # Consolidated knowledge
    st.subheader("üß© Consolidated Knowledge")
    
    consolidated_knowledge = agent.consolidation_system.consolidated_knowledge
    
    if consolidated_knowledge:
        st.success(f"C√≥ {len(consolidated_knowledge)} knowledge items ƒë√£ ƒë∆∞·ª£c consolidate")
        
        for knowledge_id, knowledge in list(consolidated_knowledge.items())[:5]:
            with st.expander(f"Knowledge: {knowledge.consolidation_method}"):
                st.write("**Summary:**", knowledge.summary)
                st.write("**Confidence:**", knowledge.confidence_score)
                st.write("**Source Memories:**", len(knowledge.source_memories))
                st.write("**Created:**", knowledge.created_at.strftime("%Y-%m-%d %H:%M:%S"))
    else:
        st.info("Ch∆∞a c√≥ knowledge n√†o ƒë∆∞·ª£c consolidate")


def settings_page():
    """Settings and configuration page"""
    st.header("‚öôÔ∏è C√†i ƒë·∫∑t")
    
    agent = st.session_state.agent
    
    st.subheader("üîß C·∫•u h√¨nh h·ªá th·ªëng")
    
    # Model settings
    with st.expander("ü§ñ Model Settings"):
        temperature = st.slider("Temperature", 0.1, 2.0, 0.8, 0.1)
        if st.button("C·∫≠p nh·∫≠t Temperature"):
            agent.config["temperature"] = temperature
            st.success("ƒê√£ c·∫≠p nh·∫≠t temperature!")
    
    # Memory settings
    with st.expander("üß† Memory Settings"):
        consolidation_threshold = st.number_input(
            "Consolidation Threshold", 
            min_value=10, 
            max_value=1000, 
            value=100
        )
        
        ewc_lambda = st.number_input(
            "EWC Lambda", 
            min_value=100.0, 
            max_value=10000.0, 
            value=1000.0
        )
        
        if st.button("C·∫≠p nh·∫≠t Memory Settings"):
            agent.consolidation_system.consolidation_threshold = consolidation_threshold
            agent.ewc_system.ewc_lambda = ewc_lambda
            st.success("ƒê√£ c·∫≠p nh·∫≠t memory settings!")
    
    # Data management
    st.subheader("üìÅ Qu·∫£n l√Ω d·ªØ li·ªáu")
    
    col1, col2 = st.columns(2)
    
    with col1:
        if st.button("üóëÔ∏è X√≥a conversation history"):
            st.session_state.conversation_history = []
            st.session_state.conversation_id = None
            st.success("ƒê√£ x√≥a conversation history!")
    
    with col2:
        if st.button("üßπ D·ªçn d·∫πp memories c≈©"):
            # Clean old experiences
            removed_count = agent.experience_buffer.clear_old_experiences(days_threshold=30)
            st.success(f"ƒê√£ x√≥a {removed_count} experiences c≈©!")
    
    # Export/Import
    st.subheader("üì§ Xu·∫•t/Nh·∫≠p d·ªØ li·ªáu")
    
    if st.button("üì§ Xu·∫•t agent state"):
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        export_path = f"data/agent_export_{timestamp}.json"
        success = agent.save_agent_state(export_path)
        
        if success:
            st.success(f"ƒê√£ xu·∫•t agent state t·ªõi: {export_path}")
        else:
            st.error("L·ªói khi xu·∫•t agent state!")
    
    # System info
    st.subheader("‚ÑπÔ∏è Th√¥ng tin h·ªá th·ªëng")
    
    status = agent.get_system_status()
    
    st.json({
        "Model Info": status['model_info'],
        "System Health": status['system_health']
    })


def main():
    st.set_page_config(
        page_title="RL Chatbot",
        page_icon="ü§ñ",
        layout="wide",
        initial_sidebar_state="expanded"
    )
    
    # Initialize session state
    initialize_session_state()
    
    # Sidebar navigation
    with st.sidebar:
        st.title("ü§ñ RL Chatbot")
        st.markdown("---")
        
        page = st.selectbox(
            "Ch·ªçn trang:",
            ["üí¨ Tr√≤ chuy·ªán", "üìä Ph√¢n t√≠ch", "üîç Kh√°m ph√° b·ªô nh·ªõ", "‚öôÔ∏è C√†i ƒë·∫∑t"]
        )
        
        st.markdown("---")
        
        # Quick stats
        agent = st.session_state.agent
        status = agent.get_system_status()
        
        st.metric("Total Interactions", status['performance_metrics']['total_interactions'])
        st.metric("Experience Buffer", f"{len(agent.experience_buffer.buffer)}/{agent.experience_buffer.max_size}")
    
    # Main content
    if page == "üí¨ Tr√≤ chuy·ªán":
        chat_interface()
    elif page == "üìä Ph√¢n t√≠ch":
        analytics_dashboard()
    elif page == "üîç Kh√°m ph√° b·ªô nh·ªõ":
        memory_explorer()
    elif page == "‚öôÔ∏è C√†i ƒë·∫∑t":
        settings_page()


if __name__ == "__main__":
    main()
